{"author":{"id":"a99b826294359757366d8d53a41dce5cf8e99657f3b1ce221b354e6a92dc7007"},"ops":[{"type":3,"timestamp":1618319192,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDgxODcyMDY4Ng==","github-url":"https://github.com/MichaelMure/git-bug/issues/530#issuecomment-818720686"},"nonce":"ZuQEt/ouQebY0kjgIN4SBGiBChI=","message":"Accidentally hit `comment` without everything written. :)","files":null},{"type":3,"timestamp":1618490745,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDgyMDM5MzkzNA==","github-url":"https://github.com/MichaelMure/git-bug/issues/530#issuecomment-820393934"},"nonce":"KgddVkl2qhelr/iUEhXSni2qjmk=","message":"Shortly before falling asleep yesterday, I got another idea. It might be possible to keep the git porcelain CLI and support new entities like PR.\nJust treat the problem in the UNIX way. E.g. every entity/context will be solved in a separate binary.\nE.g.\n- git bug -\u003e bug binary\n- git pr -\u003e pr binary\n- git identity -\u003e identity binary\n...\n\nThis would require to extract the repository logic  into a library, which will then be used by all the specific programs. So the repository will be only the persistence layer with \"contexts\". Kinda like a domain specific database library.\nOr the library defines an API by which the binaries can interact with each other. \nE.g. a merged PR, closes a specific issue. \nThis would allow to implement every binary without depending them on a specific communication technology. E.g. the \"bug binary\" will only call the \"BugAdd\" command and the \"repo library\" would then communicate over RabbitMQ or by setting some values in the git repository with the other binaries.\n\nEither way, the git porcelain CLI integration could be kept, as their are multiple binaries for each entity.\n\nJust noticed, that I'm describing a SoA/Microservice/Event-driven architecture.","files":null},{"type":6,"timestamp":1618490754,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6NDUyMTMyMjA5"},"nonce":"Njwk905lR19etKLXRw1g4nN8Gfo=","target":"bb2609d29335106c47ec5a356ca92220a046e59ce77309028c1ef071c5741472","message":"@MichaelMure Shortly before falling asleep yesterday, I got another idea. It might be possible to keep the git porcelain CLI and support new entities like PR.\nJust treat the problem in the UNIX way. E.g. every entity/context will be solved in a separate binary.\nE.g.\n- git bug -\u003e bug binary\n- git pr -\u003e pr binary\n- git identity -\u003e identity binary\n...\n\nThis would require to extract the repository logic  into a library, which will then be used by all the specific programs. So the repository will be only the persistence layer with \"contexts\". Kinda like a domain specific database library.\nOr the library defines an API by which the binaries can interact with each other. \nE.g. a merged PR, closes a specific issue. \nThis would allow to implement every binary without depending them on a specific communication technology. E.g. the \"bug binary\" will only call the \"BugAdd\" command and the \"repo library\" would then communicate over RabbitMQ or by setting some values in the git repository with the other binaries.\n\nEither way, the git porcelain CLI integration could be kept, as their are multiple binaries for each entity.\n\nJust noticed, that I'm describing a SoA/Microservice/Event-driven architecture.","files":null}]}