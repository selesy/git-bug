{"author":{"id":"be9aab73f837185c3c6275009ee7d527259c4d23685f57ceb5d65398912517e6"},"ops":[{"type":1,"timestamp":1631690937,"metadata":{"github-id":"I_kwDOCGKeh847aTVQ","github-url":"https://github.com/MichaelMure/git-bug/issues/710","origin":"github"},"nonce":"6jop8EMU9SNgZOi1hsDfOIt9ZUk=","title":"As server-side using CGI parsing","message":"Hi, I'm working on a Docker-image to help users deploy their own git-severs including common services like code-browsing/wikis etc easily.\n\nSince I use git-bug myself, I was thinking of using it as a service instead of bridging (`git-bug webui --no-open -p \u003cnumber\u003e`). This suits the purpose of both not lock-in projects and to enable use behind stringent network policies enabling users to deploy their stuff locally.\n\nI've experimented on a server-side git repo and git-bug seems to work as normal. It's state-less (apart from the intended statefullness `select` and `user adopt`) which is principally good. But it has the drawback of that it's not possible to select user without starting another process running `git-bug user adopt xxxx` first and then use the port-option for parallel processes as do differentiate users.\n\nWhat I'm wary about is the following:\n\n1) Will `git bug` run with several users simultaneously in the same directory be able to handle that (i.e. are operations atomic etc enough)?\n2) Using port-option to differentiate states of operation is awkward.  One way to achieve this is to wrap `git-bug` in a service-daemon and redirect GET/PUT requests to different processes accordingly. But it still leaves the first question unanswered. \n3) I think CGI-parsing handled by `git-bug` itself would be better. It keeps service closer to the inner logic which should make it easier to figure out corner-cases. It also makes it much easier to lock operation when git-bug is busy updating git states. It should (I hope) hence be a somewhat low hanging fruit - provided that my conclusions based on the experimentation are correct ofc.\n\nNote that I'm thinking low volume access first hand. For high volume projects, I'm sure projects can afford on premise to Jira/Gitlab etc using bridging solutions instead.","files":null}]}