{"author":{"id":"888a2a855b308f45d89690ecf3fc808aea59d56ce6d2b3a8f8aaadcea8320d6c"},"ops":[{"type":3,"timestamp":1544215485,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ0NTM2MDA4Mw==","github-url":"https://github.com/MichaelMure/git-bug/issues/75#issuecomment-445360083"},"nonce":"IMtsVJuLXDDCkGGZxdgZkPZrdwY=","message":"\u003e Just a note, this could also be handled by tagging bugs with metadata instead of physically shard them on disk.\n\nBut then you're losing some the pros of bugs being stored as references in a repo. \nE.g. moving bugs around even if you don't have `git-bug` available should be as simple as:\n```sh\n$git push remote refs/bugs/*:refs/bugs/*; \n# or something like this if it supported pathname based schemes:\n$git push remote refs/bugs/[somename]/*:refs/bugs/[someone]/* #\n```\nTags, branches, remotes, notes, essentially all types of refs can be namespaced using pathname schemes. On top of that, the entire `.git/refs/*` hierarchy can be namespaced again under `refs/namespaces/\u003csomename\u003e/`. \nNamespacing is a essential feature to maintain the distributed nature of git.\n\nAs it currently stands, `git-bug` is working like a *centralized* bugtracker in reverse.  \n\nLet's say someone doesn't like some aspect of `git-bug` forks it and starts developing independently. An impartial user can add both repos as remotes and build his own custom version. \nGit has no problem supporting this workflow. \n\nBut once this user pulls a bug from repo B he can no longer push back to repo A.\nWorse, if the user pulls from A and then B he can no longer contribute back to either repo because A and B might not be interested in the bugs of each other.\n\nAnd yes, handling this with additional metadata is possible. But I value the ability to transfer bug references across machines with `git` itself and namespacing should be familiar to anyone using `git`.","files":null}]}