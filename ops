{"author":{"id":"708ccc11728eda0dd404c8de33ac6b44bac2ffc95b2ffc6ea90ce98ccdb43935"},"ops":[{"type":3,"timestamp":1556794670,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ4ODYzMDcwNw==","github-url":"https://github.com/MichaelMure/git-bug/issues/130#issuecomment-488630707"},"nonce":"0UaiGCPH415kjggJlDDUKZjS2OA=","message":"Yes, that's the general idea. I haven't written much about it, but here goes the gist:\n- identities in git-bug are mutable even after creation, they use a chain of commits (each holding a full timestamped version of the identity) to be editable. The current active version is the last one in the chain, but git-bug can go back in time to check if the rules in a bug are valid with the identity state **at that time**. \n- each version of the identity store either zero, one or more crypto public key\n- if an identity has zero key, it is *unprotected*. That means that anybody can use it. This is useful for importers that don't necessarily have a public key at hand.\n- if an identity has at least one crypto key, it is *protected*. This means a few things:\n  - to create a new version for this identity, the new commit *must* be signed with a key present in the precedent version, otherwise it's rejected\n  - all bug editions with this identity *must* be signed with a crypto key valid *at that time*. This means that only the author can use that identity.\n  - it's not possible to revert back to unprotected\n  - key rotation/revocation can be implemented: simply create a new version without the old key and a new one\n- once this key system exist, we can add a permission scheme and roles (example: an admin can edit any comments but normal users can only edit their own)\n- if the keys are the same for git and git-bug, we can start to check commit signature on the normal (code) commits (!)\n- the identity subsystem could possibly be made into a standalone tool (ie, without git-bug) to embed and share public keys inside the git repo to check automatically commit signatures\n\nThere is a few design decision to be made:\n- does that should use GPG ? How ? CLI parameters don't seems to be standardized and that can be a pain for multi-platform.\n- should we embed our own GPG implementation ?\n- does those public keys should be published in a public GPG keystore ?\n- should we import keys from GPG ? \n- if/when the webUI start to accept users from external systems, how do we create/store keys for them ?\n\nTODO is:\n1. [ ] implement identity edition (mostly a matter of UI/UX, core is ready)\n1. [ ] implement the storage of public keys in the identities + UI/UX to interact with\n1. [ ] design \u0026 implement the storage of the corresponding private keys somewhere in the system\n1. [ ] implement commit's signature verification for git-bug data\n1. [ ] implement basic role checks (only the author can edit his comments)\n1. [ ] implement more complex roles","files":null},{"type":6,"timestamp":1618683899,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6NDUyNzI4NDQ2"},"nonce":"n3KU3g4dSfpKcxb6dM+nnS4VgTs=","target":"fa8356c5032499e4afef229d6afce05551727a8390b379e410147c7413eae5c6","message":"Yes, that's the general idea. I haven't written much about it, but here goes the gist:\n- identities in git-bug are mutable even after creation, they use a chain of commits (each holding a full timestamped version of the identity) to be editable. The current active version is the last one in the chain, but git-bug can go back in time to check if the rules in a bug are valid with the identity state **at that time**. \n- each version of the identity store either zero, one or more crypto public key\n- if an identity has zero key, it is *unprotected*. That means that anybody can use it. This is useful for importers that don't necessarily have a public key at hand.\n- if an identity has at least one crypto key, it is *protected*. This means a few things:\n  - to create a new version for this identity, the new commit *must* be signed with a key present in the precedent version, otherwise it's rejected\n  - all bug editions with this identity *must* be signed with a crypto key valid *at that time*. This means that only the author can use that identity.\n  - it's not possible to revert back to unprotected\n  - key rotation/revocation can be implemented: simply create a new version without the old key and a new one\n- once this key system exist, we can add a permission scheme and roles (example: an admin can edit any comments but normal users can only edit their own)\n- if the keys are the same for git and git-bug, we can start to check commit signature on the normal (code) commits (!)\n- the identity subsystem could possibly be made into a standalone tool (ie, without git-bug) to embed and share public keys inside the git repo to check automatically commit signatures\n\nThere is a few design decision to be made:\n- does that should use GPG ? How ? CLI parameters don't seems to be standardized and that can be a pain for multi-platform.\n- should we embed our own GPG implementation ?\n- does those public keys should be published in a public GPG keystore ?\n- should we import keys from GPG ? \n- if/when the webUI start to accept users from external systems, how do we create/store keys for them ?\n\nTODO is:\n1. [ ] implement identity edition (mostly a matter of UI/UX, core is ready)\n1. [x] implement the storage of public keys in the identities + UI/UX to interact with\n1. [ ] design \u0026 implement the storage of the corresponding private keys somewhere in the system\n1. [ ] implement commit's signature verification for git-bug data\n1. [ ] implement basic role checks (only the author can edit his comments)\n1. [ ] implement more complex roles","files":null},{"type":6,"timestamp":1618683907,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6NDUyNzI4NDU0"},"nonce":"RLAtwdbxAa7buco6ErOuY2bbd9w=","target":"fa8356c5032499e4afef229d6afce05551727a8390b379e410147c7413eae5c6","message":"Yes, that's the general idea. I haven't written much about it, but here goes the gist:\n- identities in git-bug are mutable even after creation, they use a chain of commits (each holding a full timestamped version of the identity) to be editable. The current active version is the last one in the chain, but git-bug can go back in time to check if the rules in a bug are valid with the identity state **at that time**. \n- each version of the identity store either zero, one or more crypto public key\n- if an identity has zero key, it is *unprotected*. That means that anybody can use it. This is useful for importers that don't necessarily have a public key at hand.\n- if an identity has at least one crypto key, it is *protected*. This means a few things:\n  - to create a new version for this identity, the new commit *must* be signed with a key present in the precedent version, otherwise it's rejected\n  - all bug editions with this identity *must* be signed with a crypto key valid *at that time*. This means that only the author can use that identity.\n  - it's not possible to revert back to unprotected\n  - key rotation/revocation can be implemented: simply create a new version without the old key and a new one\n- once this key system exist, we can add a permission scheme and roles (example: an admin can edit any comments but normal users can only edit their own)\n- if the keys are the same for git and git-bug, we can start to check commit signature on the normal (code) commits (!)\n- the identity subsystem could possibly be made into a standalone tool (ie, without git-bug) to embed and share public keys inside the git repo to check automatically commit signatures\n\nThere is a few design decision to be made:\n- does that should use GPG ? How ? CLI parameters don't seems to be standardized and that can be a pain for multi-platform.\n- should we embed our own GPG implementation ?\n- does those public keys should be published in a public GPG keystore ?\n- should we import keys from GPG ? \n- if/when the webUI start to accept users from external systems, how do we create/store keys for them ?\n\nTODO is:\n1. [ ] implement identity edition (mostly a matter of UI/UX, core is ready)\n1. [x] implement the storage of public keys in the identities + UI/UX to interact with\n1. [x] design \u0026 implement the storage of the corresponding private keys somewhere in the system\n1. [ ] implement commit's signature verification for git-bug data\n1. [ ] implement basic role checks (only the author can edit his comments)\n1. [ ] implement more complex roles","files":null},{"type":6,"timestamp":1618683910,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6NDUyNzI4NDU4"},"nonce":"loeOcfb2mb1TtsY6ENePj2o31MI=","target":"fa8356c5032499e4afef229d6afce05551727a8390b379e410147c7413eae5c6","message":"Yes, that's the general idea. I haven't written much about it, but here goes the gist:\n- identities in git-bug are mutable even after creation, they use a chain of commits (each holding a full timestamped version of the identity) to be editable. The current active version is the last one in the chain, but git-bug can go back in time to check if the rules in a bug are valid with the identity state **at that time**. \n- each version of the identity store either zero, one or more crypto public key\n- if an identity has zero key, it is *unprotected*. That means that anybody can use it. This is useful for importers that don't necessarily have a public key at hand.\n- if an identity has at least one crypto key, it is *protected*. This means a few things:\n  - to create a new version for this identity, the new commit *must* be signed with a key present in the precedent version, otherwise it's rejected\n  - all bug editions with this identity *must* be signed with a crypto key valid *at that time*. This means that only the author can use that identity.\n  - it's not possible to revert back to unprotected\n  - key rotation/revocation can be implemented: simply create a new version without the old key and a new one\n- once this key system exist, we can add a permission scheme and roles (example: an admin can edit any comments but normal users can only edit their own)\n- if the keys are the same for git and git-bug, we can start to check commit signature on the normal (code) commits (!)\n- the identity subsystem could possibly be made into a standalone tool (ie, without git-bug) to embed and share public keys inside the git repo to check automatically commit signatures\n\nThere is a few design decision to be made:\n- does that should use GPG ? How ? CLI parameters don't seems to be standardized and that can be a pain for multi-platform.\n- should we embed our own GPG implementation ?\n- does those public keys should be published in a public GPG keystore ?\n- should we import keys from GPG ? \n- if/when the webUI start to accept users from external systems, how do we create/store keys for them ?\n\nTODO is:\n1. [ ] implement identity edition (mostly a matter of UI/UX, core is ready)\n1. [x] implement the storage of public keys in the identities + UI/UX to interact with\n1. [x] design \u0026 implement the storage of the corresponding private keys somewhere in the system\n1. [x] implement commit's signature verification for git-bug data\n1. [ ] implement basic role checks (only the author can edit his comments)\n1. [ ] implement more complex roles","files":null},{"type":2,"timestamp":1557086705,"metadata":{"github-id":"MDE3OlJlbmFtZWRUaXRsZUV2ZW50MjMxOTc2NjcxOA=="},"nonce":"4sKcTO3yu9ir4GZhoG+1f3vLtHE=","title":"Identity management: step two","was":"Identity management: step two"},{"type":3,"timestamp":1587768905,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDYxOTI3MTYwMA==","github-url":"https://github.com/MichaelMure/git-bug/issues/130#issuecomment-619271600"},"nonce":"aQ61lrREqLNhlRTeHCjP7qTHgls=","message":"Some of this is happening in https://github.com/MichaelMure/git-bug/pull/376","files":null},{"type":3,"timestamp":1618683973,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDgyMTg2NjUyMQ==","github-url":"https://github.com/MichaelMure/git-bug/issues/130#issuecomment-821866521"},"nonce":"o5k8yu+EWUW2aapOeb+74k2Yvgg=","message":"Still a lot to do, but git-bug's core can now store/load crypto keys and check signatures.","files":null}]}